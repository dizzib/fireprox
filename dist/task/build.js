// Generated by LiveScript 1.2.0
(function(){
  var Assert, Cron, Emitter, Fs, Gaze, Globule, _, Md, Path, Shell, WFib, W4, W4m, Dirname, Dir, G, NMODULES, pruner, tasks, me, ref$;
  Assert = require('assert');
  Cron = require('cron');
  Emitter = require('events').EventEmitter;
  Fs = require('fs');
  Gaze = require('gaze');
  Globule = require('globule');
  _ = require('lodash');
  Md = require('marked');
  Path = require('path');
  Shell = require('shelljs/global');
  WFib = require('wait.for').launchFiber;
  W4 = require('wait.for')['for'];
  W4m = require('wait.for').forMethod;
  Dirname = require('./constants').dirname;
  Dir = require('./constants').dir;
  G = require('./growl');
  NMODULES = './node_modules';
  pruner = new Cron.CronJob({
    cronTime: '*/10 * * * *',
    onTick: pruneEmptyDirs
  });
  tasks = {
    livescript: {
      cmd: NMODULES + "/LiveScript/bin/lsc --output $OUT $IN",
      ixt: 'ls',
      oxt: 'js',
      xsub: 'json.js->json'
    },
    markdown: {
      cmd: markdown,
      ixt: 'md',
      oxt: 'html'
    }
  };
  module.exports = me = (ref$ = clone$(new Emitter()), ref$.compileFiles = function(){
    var tid, e;
    try {
      for (tid in tasks) {
        compileBatch(tid);
      }
      return me.emit('built');
    } catch (e$) {
      e = e$;
      return G.err(e);
    }
  }, ref$.refreshModules = function(){
    Assert.equal(pwd(), Dir.DIST);
    W4(exec, 'npm -v');
    W4(exec, 'npm prune');
    return W4(exec, 'npm install');
  }, ref$.start = function(){
    var tid;
    G.say('build started');
    try {
      pushd(Dir.ROOT);
      for (tid in tasks) {
        startWatching(tid);
      }
    } finally {
      popd();
    }
    return pruner.start();
  }, ref$.stop = function(){
    var i$, ref$, t, ref1$;
    pruner.stop();
    for (i$ in ref$ = tasks) {
      t = ref$[i$];
      if ((ref1$ = t.gaze) != null) {
        ref1$.close();
      }
    }
    return G.say('build stopped');
  }, ref$);
  function compile(t, ipath, cb){
    var odir, opath, cmd;
    odir = Path.dirname(opath = getOpath(t, ipath));
    switch (typeof t.cmd) {
    case 'string':
      cmd = t.cmd.replace('$IN', "'" + ipath + "'").replace('$OUT', "'" + odir + "'");
      return exec(cmd, function(code, res){
        if (code) {
          log(code, res);
        }
        return cb(code ? res : void 8, opath);
      });
    case 'function':
      return t.cmd(ipath, opath, function(e){
        return cb(e, opath);
      });
    }
  }
  function compileBatch(tid){
    var t, w, files, res$, dir, paths, i$, len$, f, info;
    t = tasks[tid];
    w = W4m(t.gaze, 'watched');
    res$ = [];
    for (dir in w) {
      paths = w[dir];
      for (i$ = 0, len$ = paths.length; i$ < len$; ++i$) {
        f = paths[i$];
        if ('/' !== f.slice(-1) && Path.basename(f)[0] !== t.mixn) {
          res$.push(f);
        }
      }
    }
    files = res$;
    files = _.filter(files, t.isMatch);
    info = files.length + " " + tid + " files";
    G.say("compiling " + info + "...");
    for (i$ = 0, len$ = files.length; i$ < len$; ++i$) {
      f = files[i$];
      W4(compile, t, f);
    }
    return G.ok("...done " + info + "!");
  }
  function getOpath(t, ipath){
    var p, xsub, ref$;
    p = ipath.replace(Dir.ROOT + "/", '').replace(t.ixt, t.oxt);
    if ((xsub = (ref$ = t.xsub) != null ? ref$.split('->') : void 8) == null) {
      return p;
    }
    return p.replace(xsub[0], xsub[1]);
  }
  function markdown(ipath, opath, cb){
    return Md(cat(ipath), function(e, html){
      if (e == null) {
        html.to(opath);
      }
      return cb(e);
    });
  }
  function pruneEmptyDirs(){
    if (pwd() !== Dir.DIST) {
      return log('bypass prune-empty-dirs');
    }
    Assert.equal(pwd(), Dir.DIST);
    return exec("find . -type d -empty -delete", function(code, out){
      if (code) {
        return G.err("prune failed: " + code + " " + out);
      }
    });
  }
  function startWatching(tid){
    var ixt, t, dirs;
    log("start watching " + tid);
    ixt = (t = tasks[tid]).ixt;
    dirs = Dirname.SITE + "," + Dirname.TASK;
    t.isMatch = function(ipath){
      return Globule.isMatch(t.patterns, ipath.replace(Dir.ROOT + "/", ''));
    };
    return t.gaze = Gaze(t.patterns = ["*." + ixt, "{" + dirs + "}/**/*." + ixt], function(){
      return t.gaze.on('all', function(act, ipath){
        if ('/' === ipath.slice(-1)) {
          return;
        }
        if (!t.isMatch(ipath)) {
          return;
        }
        log(act, ipath);
        return WFib(function(){
          var e, opath;
          if (t.mixn != null && Path.basename(ipath)[0] === t.mixn) {
            try {
              return compileBatch(tid);
            } catch (e$) {
              e = e$;
              return G.err(e);
            }
          } else {
            switch (act) {
            case 'added':
            case 'changed':
            case 'renamed':
              try {
                opath = W4(compile, t, ipath);
                me.emit('built');
              } catch (e$) {
                e = e$;
                return G.alert(e);
              }
              return G.ok(opath);
            case 'deleted':
              try {
                W4m(Fs, 'unlink', opath = getOpath(t, ipath));
              } catch (e$) {
                e = e$;
                if (e.code !== 'ENOENT') {
                  throw e;
                }
              }
              return G.ok("Delete " + opath);
            }
          }
        });
      });
    });
  }
  function clone$(it){
    function fun(){} fun.prototype = it;
    return new fun;
  }
}).call(this);
